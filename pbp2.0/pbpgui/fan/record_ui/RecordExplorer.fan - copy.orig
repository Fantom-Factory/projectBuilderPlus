using fwt
using gfx
using pbpcore
using concurrent
using pbplogging

class RecordExplorer : EdgePane,  UiUpdatable
{

  private ToolBar recordToolbar
  private Table recordTable
  private RecTableModel? recordTableModel
  private PaginationController paginationController := PaginationController()
  private LimitController limitController := LimitController()

  new make(PbpListener pbpListener) : super()
  {
    center = recordTable = Table{multi=true}
    recordTable.model = BlankTableModel()
    recordTable.onKeyDown.add |Event e| {

      if (e.key == Key.esc) {
        recordTable.selected = [,]
      }
      
      if ((e.key == (Key.ctrl + Key.a)) || e.key == (Key.command + Key.a)) {
        recordTable.selected = [,]
        rowIdx := [,]
        recordTableModel.rows.each |row, idx| {
          rowIdx.push(idx)
        }
        recordTable.selected = rowIdx
      }
    }
    top = recordToolbar = RecordCommands(pbpListener).getToolbar
    bottom = ButtonGrid{numCols=3; /*Button(ShowAll(this)),*/
                        Label{text="Limit"},
                        limitController,
                        paginationController,}
  }

  Void update(Map recMap)
  {
    if (recordTableModel == null) {
      throw Err("Invalid state: setTableModel not called before update call.")
    }
   
    recordTableModel.update(recMap)
  }

  Void refreshAll()
  {
    recordTable.refreshAll
  }

  Record[] getSelected()
  {
    return recordTableModel.getRows(recordTable.selected)
  }

  Void addOnTableAction(|Event e| f)
  {
    recordTable.onAction.add(f)
  }

  Void addOnPopupTableAction(|Event e| f)
  {
    recordTable.onPopup.add(f)
  }
  
  Void clearTableSelection()
  {
    recordTable.selected = [,]
  }

  Void sendMsgToModelController(Obj? msg)
  {
    recordTableModel.controller.send(msg)
  }

  Int getAuxRowsSize()
  {
    recordTableModel.auxRows.size
  }

  Obj? getPaginationFirstPage()
  {
    paginationController.pages.first
  }

  Void addToolbarCommand(Command command)
  {
    recordToolbar.addCommand(command)
  }

  Void setTableModel(RecTableModel model)
  {
    recordTableModel = model
    recordTable.model = model
    recordTableModel.attachController(RecordExpPaginationHandler(this.limitController.limit, this.paginationController))
    recordTableModel.controller.send(recordTableModel.rows.size)
    recordTable.refreshAll
  }

  override Void updateUi(Obj? params := null)
  {
    if(params is Range)
    {
      recordTableModel.updateUi(params)
      recordTable.refreshAll
    }
  }

}

class LimitController : Text, UiCommunicator
{
  AtomicRef limit := AtomicRef(100)
  new make() : super()
  {
    this.text = "100"
    onAction.add |e|
    {
      if(Int.fromStr(this.text,10,false)!=null)
      {
        limit.getAndSet(Int.fromStr(this.text,10,false))
        communicate(null)
        this.relayout
        this.parent.relayout
      }
    }
  }
  override Size prefSize(Hints hints:=Hints.defVal)
  {
    return Size(this.text.size*Desktop.sysFont.size.toInt+11,super.prefSize(hints).h)
  }
  override Void communicate(Obj? params)
  {
    if(this.parent.parent is RecordExplorer)
    {
        recExp := this.parent.parent as RecordExplorer
        recExp.sendMsgToModelController(recExp.getAuxRowsSize)
        recExp.updateUi(recExp.getPaginationFirstPage)
        recExp.refreshAll
    }
  }
}


const class RecordExpPaginationHandler : Actor
{
  const Str pHandler := Uuid().toStr
  const AtomicRef limitController
  new make(AtomicRef limitController, PaginationController paginationController) : super(ActorPool())
  {
    this.limitController = limitController
    Actor.locals[pHandler] = paginationController
  }

  override Obj? receive(Obj? msg)
  {
    Desktop.callAsync |->|
    {
      updatePages(msg)
    }
    return null
  }

  Void updatePages(Obj? msg)
  {
    Int totalsize := msg
    Int pages := 1
    Int limit := limitController.val
    if(limit>totalsize)
    {
      limit = totalsize
    }
    if(totalsize > 100)
    {
      pages = (totalsize / limit)
      if(totalsize-(limit*pages)>0){pages++}
    }
   if(pages > 1)
   {
     Range[] pageRanges := [,]
     //Paginate
     pages.times |index|
     {
       Range newRange := index*limit..(index+1)*limit
       pageRanges.push(newRange)
     }
     if((pageRanges.last.last)!=(totalsize-1))
     {
       pageRanges[pages-1] = pageRanges[pages-1].first..totalsize-1
     }
     paginator := Actor.locals[pHandler] as PaginationController
     if(paginator!=null)
     {
       paginator.updateUi(pageRanges)
     }
   }
   }
}

